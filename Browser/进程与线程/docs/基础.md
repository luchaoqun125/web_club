### 浏览器都包含哪些进程？

> 知道了浏览器是多进程后，列举主要进程:

1. Browser进程：浏览器的主进程（负责协调、主控），只有一个。作用有

  - 负责浏览器界面显示，与用户交互。如前进，后退等
  - 负责各个页面的管理，创建和销毁其他进程
  - 将Renderer进程得到的内存中的Bitmap，绘制到用户界面上
  - 网络资源的管理，下载等

2. 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建
3. GPU进程：图形处理器，最多一个，用于3D绘制等
4. 浏览器渲染进程（浏览器内核）（Renderer进程，内部是多线程的）：默认每个Tab页面一个进程，互不影响。主要作用为

页面渲染，脚本执行，事件处理等

强化记忆：在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程）

### 多进程的优势

- 避免单个page crash影响整个浏览器
- 避免第三方插件crash影响整个浏览器
- 多进程充分利用多核优势
- 方便使用沙盒模型隔离插件等进程，提高浏览器稳定性


#### 浏览器内核（渲染进程）
> 浏览器的渲染进程是多线程的

1. GUI渲染线程，（图形用户界面）

- 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。
- 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行
- 注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），- GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。
  
2. JS引擎线程
  - 负责处理Javascript脚本程序
  - GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。
  
3. 事件触发线程
4. 定时触发器线程
5. 异步http请求线程

![Image text](../imgs/borwor.png)


### Browser进程和浏览器内核（Renderer进程）的通信过程

- Browser进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过RendererHost接口传递给Render进程
- Renderer进程的Renderer接口收到消息，简单解释后，交给渲染线程，然后开始渲染

  - 渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染
  - 当然可能会有JS线程操作DOM（这样可能会造成回流并重绘）
  - 最后Render进程将结果传递给Browser进程
- Browser进程接收到结果并将结果绘制出来
![Image text](../imgs/browser_render.png)

### 梳理浏览器内核中线程之间的关系
1. GUI渲染线程与JS引擎线程互斥
 > 由于JavaScript是可操纵DOM的，当JS线程和UI线程同时运行，渲染结果可能无法控制。
 > 因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起，GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行
2. JS阻塞页面加载
> 因为JS在执行过程中，GUI的更新会暂时保存在队列中，JS如果执行时间过长就会阻塞页面，所以，要尽量避免JS执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。
3. WebWorker，浏览器的子线程
  > 创建Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）
  > JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）
如果有非常耗时的工作，请单独开一个Worker线程, 只待计算出结果后，将结果通信给主线程即可

4. WebWorker与SharedWorker
  - WebWorker只属于某个页面，不会和其他页面的Render进程（浏览器内核进程）共享
  - SharedWorker是浏览器所有页面共享的，不能采用与Worker同样的方式实现，因为它不隶属于某个Render进程，可以为多个Render进程共享使用
SharedWorker由独立的进程管理，WebWorker只是属于render进程下的一个线程


